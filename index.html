<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Matrix Dev Escape - Precision</title>

    <style>
      :root {
        --matrix-green: #00ff41;
        --bg: #000;
        --grid-color: rgba(0, 255, 65, 0.15);
        --modal-bg: rgba(0, 10, 0, 0.98);
        --game-width: 450px;
        --phase-color: var(--matrix-green);
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #0a0a0a;
        color: var(--matrix-green);
        font-family: "Courier New", monospace;
        overflow: hidden;
        display: flex;
        justify-content: center;
      }

      #mobile-container {
        width: 100%;
        max-width: var(--game-width);
        height: 100vh;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        border-left: 1px solid #222;
        border-right: 1px solid #222;
        position: relative;
      }

      /* ADIÇÃO: BARRA DE INFORMAÇÕES NO TOPO */
      #top-info {
        padding: 10px;
        background: #000;
        border-bottom: 2px solid var(--phase-color);
        display: flex;
        justify-content: space-between;
        font-size: 0.8rem;
        font-weight: bold;
        z-index: 20;
      }

      #viewport {
        flex: 1;
        overflow: auto;
        scroll-snap-type: both mandatory;
        -webkit-overflow-scrolling: touch;
        border-bottom: 1px solid var(--phase-color);
        position: relative;
      }

      #world-mask {
        position: absolute;
        top: 0;
        left: 0;
        width: 1000%;
        height: 1000%;
        pointer-events: none;
        z-index: 10;
        background: radial-gradient(
          circle 120px at var(--vx) var(--vy),
          transparent 0%,
          rgba(0, 0, 0, 1) 100%
        );
        display: none;
      }

      #world {
        display: grid;
        grid-template-columns: repeat(10, var(--game-width));
        grid-template-rows: repeat(10, 70vh);
        width: calc(var(--game-width) * 10);
        height: 700vh;
      }

      .section {
        width: var(--game-width);
        height: 70vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        scroll-snap-align: start;
        padding: 20px;
        box-sizing: border-box;
        border: 1px solid rgba(0, 255, 65, 0.05);
      }

      .coord-label {
        opacity: 0.4;
        font-size: 1.2rem;
        font-weight: bold;
      }

      #footer {
        height: 160px;
        background: #000;
        display: flex;
        padding: 10px;
        gap: 10px;
        border-top: 2px solid var(--phase-color);
      }

      #mini-map {
        flex: 1;
        height: 100%;
        border: 2px solid var(--phase-color);
        position: relative;
        overflow: hidden;
        background-image: linear-gradient(
            to right,
            var(--grid-color) 1px,
            transparent 1px
          ),
          linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
        background-size: 10% 10%;
        box-shadow: 0 0 10px var(--phase-color);
      }

      #map-light {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: 5;
        pointer-events: none;
        display: none;
      }

      #player-dot {
        position: absolute;
        width: 6px;
        height: 6px;
        background: #fff;
        border-radius: 50%;
        box-shadow: 0 0 8px #fff;
        z-index: 15;
        transform: translate(-50%, -50%);
      }

      .task-node {
        position: absolute;
        width: 4px;
        height: 4px;
        background: var(--phase-color);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 2;
        opacity: 1;
      }

      .btn {
        background: transparent;
        border: 1px solid var(--phase-color);
        color: var(--phase-color);
        padding: 8px;
        cursor: pointer;
        font-family: "Courier New";
      }

      #modal-overlay {
        display: none;
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 100;
        justify-content: center;
        align-items: center;
      }

      #modal {
        background: var(--modal-bg);
        border: 1px solid var(--phase-color);
        padding: 20px;
        width: 85%;
        text-align: center;
      }

      #modal input {
        background: #000;
        border: 1px solid var(--phase-color);
        color: var(--phase-color);
        width: 90%;
        padding: 10px;
        margin: 10px 0;
        font-family: "Courier New";
      }

      .skill-tag {
        display: inline-block;
        padding: 2px 4px;
        border: 1px solid var(--phase-color);
        margin: 2px;
        font-size: 0.6rem;
      }
    </style>
  </head>

  <body>
    <div id="mobile-container">
      <div id="top-info">
        <span id="top-phase-name">PHASE: ???</span>
        <span id="top-progress">NODES: 0/0</span>
      </div>

      <div id="viewport">
        <div id="world-mask"></div>
        <div id="world"></div>
      </div>

      <div id="footer">
        <div id="mini-map">
          <div id="map-light"></div>
          <div id="player-dot"></div>
        </div>
        <div style="flex: 1; font-size: 0.7rem; overflow-y: auto">
          <strong
            id="phase-label"
            style="
              display: block;
              color: var(--phase-color);
              margin-bottom: 4px;
            "
            >PHASE</strong
          >
          <div id="skill-list">Nenhuma</div>
        </div>
      </div>

      <div id="modal-overlay">
        <div id="modal">
          <h3 id="modal-title"></h3>
          <p id="modal-question"></p>
          <div id="modal-body"></div>
          <div id="modal-footer" style="margin-top: 15px">
            <button class="btn" onclick="closeModal()">CLOSE</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const gameFases = [
        {
          id: 0,
          nome: "ESTRUTURA",
          escuro: false,
          color: "#00ff41",
          data: {
            "1,1": {
              q: "Qual tag define o corpo do HTML?",
              a: "body",
              skill: "HTML_BODY",
            },
            "2,4": {
              q: "Qual atributo define o caminho de um script JS?",
              a: "src",
              skill: "HTML_SCRIPT_SRC",
            },
            "3,3": {
              q: "Comando Linux para listar arquivos?",
              a: "ls",
              skill: "LINUX_LS",
            },
            "6,2": {
              q: "Comando Linux para criar diretório?",
              a: "mkdir",
              skill: "LINUX_MKDIR",
            },
            "1,2": {
              q: "Qual palavra cria uma constante no JavaScript?",
              options: ["var", "let", "const"],
              a: 2,
              skill: "JS_CONST",
            },
            "5,5": { type: "EXIT" },
          },
        },

        {
          id: 1,
          nome: "DOCKER & JS",
          escuro: true,
          color: "#00d4ff",
          data: {
            "1,2": {
              q: "Qual palavra cria uma constante no JavaScript?",
              options: ["var", "let", "const"],
              a: 2,
              skill: "JS_CONST",
            },
            "2,6": {
              q: "Qual método converte JSON em objeto JavaScript?",
              a: "json.parse",
              skill: "JS_JSON_PARSE",
            },
            "4,4": {
              q: "Docker: comando para listar containers em execução?",
              a: "docker ps",
              skill: "DOCKER_PS",
            },
            "6,1": {
              q: "Qual arquivo define instruções de build no Docker?",
              options: ["docker.json", "dockerfile", "docker-compose.yml"],
              a: 1,
              skill: "DOCKERFILE",
            },
            "9,9": { type: "EXIT" },
          },
        },

        {
          id: 2,
          nome: "GIT CONTROL",
          escuro: true,
          color: "#f05032",
          data: {
            "1,8": {
              q: "Comando Git para clonar um repositório?",
              a: "git clone",
              skill: "GIT_CLONE",
            },
            "3,2": {
              q: "Qual comando cria um commit?",
              options: ["git push", "git commit", "git add"],
              a: 1,
              skill: "GIT_COMMIT",
            },
            "5,5": {
              q: "Qual comando adiciona arquivos ao stage?",
              options: ["git add", "git status", "git log"],
              a: 0,
              skill: "GIT_ADD",
            },
            "7,3": {
              q: "Qual comando troca de branch?",
              options: ["git checkout", "git branch", "git merge"],
              a: 0,
              skill: "GIT_CHECKOUT",
            },
            "9,9": { type: "EXIT" },
          },
        },

        {
          id: 3,
          nome: "VUE CORE",
          escuro: false,
          color: "#42b883",
          data: {
            "2,2": {
              q: "Qual diretiva Vue renderiza listas?",
              options: ["v-if", "v-for", "v-bind"],
              a: 1,
              skill: "VUE_VFOR",
            },
            "3,4": {
              q: "Qual diretiva Vue faz bind de atributos?",
              options: ["v-model", "v-bind", "v-on"],
              a: 1,
              skill: "VUE_VBIND",
            },
            "6,2": {
              q: "Qual hook é executado ao montar o componente (Vue 3)?",
              a: "onmounted",
              skill: "VUE_ONMOUNTED",
            },
            "7,6": {
              q: "Qual função cria estado reativo simples no Vue 3?",
              options: ["reactive", "ref", "computed"],
              a: 1,
              skill: "VUE_REF",
            },
            "9,9": { type: "EXIT" },
          },
        },

        {
          id: 4,
          nome: "REACT MATRIX",
          escuro: true,
          color: "#61dafb",
          data: {
            "1,3": {
              q: "Qual hook gerencia estado no React?",
              options: ["useEffect", "useState", "useContext"],
              a: 1,
              skill: "REACT_USESTATE",
            },
            "3,5": {
              q: "Qual hook executa efeitos colaterais?",
              options: ["useMemo", "useEffect", "useRef"],
              a: 1,
              skill: "REACT_USEEFFECT",
            },
            "5,2": {
              q: "Qual prop é obrigatória ao renderizar listas?",
              options: ["id", "index", "key"],
              a: 2,
              skill: "REACT_KEY",
            },
            "7,7": {
              q: "Biblioteca padrão de roteamento no React?",
              options: ["react-router", "redux", "next"],
              a: 0,
              skill: "REACT_ROUTER",
            },
            "9,9": { type: "EXIT" },
          },
        },

        {
          id: 5,
          nome: "NODE & TYPESCRIPT",
          escuro: true,
          color: "#3178c6",
          data: {
            "2,1": {
              q: "Comando para iniciar um projeto Node.js?",
              a: "npm init",
              skill: "NODE_NPM_INIT",
            },
            "4,3": {
              q: "Qual objeto é global no Node.js?",
              options: ["window", "document", "global"],
              a: 2,
              skill: "NODE_GLOBAL",
            },
            "5,6": {
              q: "Qual extensão padrão de arquivos TypeScript?",
              options: [".js", ".tsx", ".ts"],
              a: 2,
              skill: "TS_EXTENSION",
            },
            "7,2": {
              q: "Qual comando compila arquivos TypeScript?",
              options: ["ts-node", "npm build", "tsc"],
              a: 2,
              skill: "TS_TSC",
            },
            "9,9": { type: "EXIT" },
          },
        },
      ];

      let currentFaseIdx = 0;
      let inventory = [];
      let currentCoord = "";

      const world = document.getElementById("world");
      const viewport = document.getElementById("viewport");
      const minimap = document.getElementById("mini-map");
      const dot = document.getElementById("player-dot");
      const light = document.getElementById("map-light");
      const worldMask = document.getElementById("world-mask");
      const overlay = document.getElementById("modal-overlay");

      function loadPhase(idx) {
        currentFaseIdx = idx;
        inventory = [];
        world.innerHTML = "";
        minimap.querySelectorAll(".task-node").forEach((n) => n.remove());

        const fase = gameFases[idx];

        document.documentElement.style.setProperty("--phase-color", fase.color);
        document.getElementById("phase-label").innerText =
          "PHASE: " + fase.nome;
        document.getElementById("top-phase-name").innerText =
          "PHASE: " + fase.nome;
        updateInventoryUI();

        worldMask.style.display = fase.escuro ? "block" : "none";
        light.style.display = fase.escuro ? "block" : "none";

        for (let r = 0; r < 10; r++) {
          for (let c = 0; c < 10; c++) {
            const coord = `${c},${r}`;
            const sec = document.createElement("section");
            sec.className = "section";

            if (fase.data[coord]) {
              const node = document.createElement("div");
              node.className = "task-node";
              node.id = `node-${coord}`;
              node.style.left = `${c * 10 + 5}%`;
              node.style.top = `${r * 10 + 5}%`;
              node.style.opacity = fase.escuro ? "0" : "1";
              if (fase.data[coord].type === "EXIT")
                node.style.background = "gold";
              minimap.appendChild(node);

              const isExit = fase.data[coord].type === "EXIT";
              sec.innerHTML = `<h2>[ ${isExit ? "EXIT" : "NODE"} ${coord} ]</h2>
                <button class="btn" onclick="${
                  isExit ? "checkExit()" : `openTerminal('${coord}')`
                }">${isExit ? "UNSEAL" : "ACCESS"}</button>`;
            } else {
              sec.innerHTML = `<span class="coord-label">${coord}</span>`;
            }
            world.appendChild(sec);
          }
        }
        viewport.scrollTo(0, 0);
      }

      function openTerminal(coord) {
        currentCoord = coord;
        const data = gameFases[currentFaseIdx].data[coord];
        document.getElementById("modal-title").innerText = "TERMINAL " + coord;
        document.getElementById("modal-question").innerText = data.q;
        const body = document.getElementById("modal-body");
        body.innerHTML = "";

        if (data.options) {
          data.options.forEach((opt, i) => {
            const b = document.createElement("button");
            b.className = "btn";
            b.style.width = "100%";
            b.innerText = opt;
            b.onclick = () => validate(i);
            body.appendChild(b);
          });
        } else {
          body.innerHTML = `<input type="text" id="ans" placeholder="Answer..." autocomplete="off">
                           <button class="btn" style="width:100%" onclick="validate()">EXECUTE</button>`;
          setTimeout(() => document.getElementById("ans").focus(), 150);
        }
        overlay.style.display = "flex";
      }

      function validate(choiceIdx = null) {
        const data = gameFases[currentFaseIdx].data[currentCoord];
        let isCorrect = false;

        if (choiceIdx !== null) isCorrect = choiceIdx === data.a;
        else
          isCorrect =
            document.getElementById("ans").value.toLowerCase().trim() ===
            data.a;

        if (isCorrect) {
          if (!inventory.includes(data.skill)) inventory.push(data.skill);
          document.getElementById(`node-${currentCoord}`).style.background =
            "#fff";
          updateInventoryUI();
          closeModal();
        } else {
          document.getElementById("modal-question").innerText =
            "ACCESS DENIED - RETRY";
        }
      }

      function checkExit() {
        const faseData = gameFases[currentFaseIdx].data;
        const required = Object.keys(faseData).filter(
          (k) => faseData[k].skill
        ).length;

        if (inventory.length >= required) {
          if (currentFaseIdx < gameFases.length - 1) {
            loadPhase(currentFaseIdx + 1);
          } else {
            document.getElementById("modal-title").innerText = "SYSTEM CRACKED";
            document.getElementById("modal-question").innerText =
              "Você escapou da Matrix.";
            overlay.style.display = "flex";
          }
        } else {
          document.getElementById("modal-title").innerText = "EXIT LOCKED";
          document.getElementById(
            "modal-question"
          ).innerText = `Nodes necessários: ${inventory.length}/${required}`;
          overlay.style.display = "flex";
        }
      }

      function updateInventoryUI() {
        const list = document.getElementById("skill-list");
        const topProg = document.getElementById("top-progress");
        const faseData = gameFases[currentFaseIdx].data;
        const required = Object.keys(faseData).filter(
          (k) => faseData[k].skill
        ).length;

        list.innerHTML = inventory.length
          ? inventory.map((s) => `<span class="skill-tag">${s}</span>`).join("")
          : "Nenhuma";
        topProg.innerText = `NODES: ${inventory.length}/${required}`;
      }

      function closeModal() {
        overlay.style.display = "none";
      }

      viewport.addEventListener("scroll", () => {
        const pctX =
          viewport.scrollLeft /
          (viewport.scrollWidth - viewport.clientWidth || 1);
        const pctY =
          viewport.scrollTop /
          (viewport.scrollHeight - viewport.clientHeight || 1);
        const mapW = minimap.clientWidth;
        const mapH = minimap.clientHeight;
        const posX = pctX * (mapW * 0.9) + mapW * 0.05;
        const posY = pctY * (mapH * 0.9) + mapH * 0.05;

        dot.style.left = posX + "px";
        dot.style.top = posY + "px";

        if (gameFases[currentFaseIdx].escuro) {
          light.style.background = `radial-gradient(circle 40px at ${posX}px ${posY}px, rgba(255,255,255,0.2) 0%, #000 100%)`;
          const vx = viewport.scrollLeft + viewport.clientWidth / 2;
          const vy = viewport.scrollTop + viewport.clientHeight / 2;
          worldMask.style.setProperty("--vx", vx + "px");
          worldMask.style.setProperty("--vy", vy + "px");

          minimap.querySelectorAll(".task-node").forEach((node) => {
            const nx = (parseFloat(node.style.left) * mapW) / 100;
            const ny = (parseFloat(node.style.top) * mapH) / 100;
            const d = Math.hypot(nx - posX, ny - posY);
            node.style.opacity = d < 40 ? "1" : "0";
          });
        } else {
          minimap
            .querySelectorAll(".task-node")
            .forEach((n) => (n.style.opacity = "1"));
        }
      });

      loadPhase(0);
    </script>
  </body>
</html>
